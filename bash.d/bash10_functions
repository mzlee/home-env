# .bash_functions
function choice {
    file=${1}
    lc=$(wc -l < $file)

    if [ ${lc} -gt 0 ]; then
	sed -n "$((1 + $RANDOM % ${lc})) p" ${file}
    fi
}

function check_machine {
    local ulist=$(ssh $LAST_PUBLIC "users");
    for u in ${ulist}; do
	if [ ${u} != "mzlee" ]
	then
	    debug "${u}"
	    LAST_PUBLIC=""
	fi
    done
}

function new_machine {
    export LAST_PUBLIC=""
    pub_machine
}

function pub_machine {
    local DOMAIN=${DOMAIN:-cs.utexas.edu}
    if [ -f ${HOME}/.${DOMAIN} ]; then
	if [ -n "${LAST_PUBLIC}" ]; then
	    check_machine
	fi

	while [ -z "${LAST_PUBLIC}" ]; do
	    local mach=$(choice ${HOME}/.${DOMAIN})
	    if [ ${mach:0:1} == "#" ]; then
		continue
	    fi
	    echo "Trying ${mach}..."
	    LAST_PUBLIC="${mach}.${DOMAIN}"
	    check_machine
	done
    fi
    export LAST_PUBLIC
}

function pub_connect {
    local DOMAIN=${DOMAIN:-cs.utexas.edu}
    if [ -f ${HOME}/.${DOMAIN} ]; then
	pub_machine
	ssh $(whoami)@${LAST_PUBLIC} ${@}
    fi
}

function pub_cpto {
    local DOMAIN=${DOMAIN:-cs.utexas.edu}
    if [ -f ${HOME}/.${DOMAIN} ]; then
	pub_machine
	local SRC=${1}
	local DEST=${2:-${SRC}}
	scp ${SRC} $(whoami)@${LAST_PUBLIC}:${DEST}
    fi
}

function pub_cpfrom {
    local DOMAIN=${DOMAIN:-cs.utexas.edu}
    if [ -f ${HOME}/.${DOMAIN} ]; then
	pub_machine
	local SRC=${1}
	local DEST=${2:-${SRC}}
	scp $(whoami)@${LAST_PUBLIC}:${SRC} ${DEST}
    fi
}

function proxy_connect {
    local PROXY_PORT=${PROXY_PORT:-8080}
    local PROXY_HOST=${PROXY_HOST:-chopin}
    ssh -D ${PROXY_PORT} -Nf ${PROXY_HOST}
    sudo networksetup -setsocksfirewallproxystate Wi-Fi on
}

function proxy_disconnect {
    local PROXY_PORT=${PROXY_PORT:-8080}
    local PROXY_PID=$(lsof -t -i @localhost:${PROXY_PORT} -sTCP:listen)
    if [ -n "${PROXY_PID}" ]; then
	kill ${PROXY_PID}
	sudo networksetup -setsocksfirewallproxystate Wi-Fi off
   fi
}

OLD_CP=/bin/cp

function cp {
    local args=( $@ )
    local progress=0
    local i=0
    for arg in ${args}; do
	if [ $arg = "--progress" ]; then
	    progress=1
	fi
	i=$(( ${i} + 1 ))
    done

    if [ $PLATFORM = linux ]; then
	if [ $progress = 0 ]; then
	    ${OLD_CP} ${args[@]}
	else
	    i=0
	    for arg in ${args[@]}; do
		if [ ${arg:0:1} = "-" ]; then
		    unset args[i]
		fi
		i=$(( ${i} + 1 ))
	    done
	    cp_p ${args[@]}
	fi
    else
	${OLD_CP} ${args[@]}
    fi
}

function cp_p
{
   strace -q -ewrite ${OLD_CP} -- "${1}" "${2}" 2>&1 \
      | awk '{
        count += $NF
            if (count % 10 == 0) {
               percent = count / total_size * 100
               printf "%3d%% [", percent
               for (i=0;i<=percent;i++)
                  printf "="
               printf ">"
               for (i=percent;i<100;i++)
                  printf " "
               printf "]\r"
            }
         }
         END { print "" }' total_size=$(stat -c '%s' "${1}") count=0
}

function papers
{
    if [ -n "${PAPERS_DIR}" ]; then
	DIR=$(echo $1|tr '[:lower:]' '[:upper:]')
	IFS_BAK=$IFS
	IFS=$'\n'
	if [ -z "${DIR}" ]; then
	    local count=0
	    for d in $(ls -1 $PAPERS_DIR); do
		if [ "${d#*\(}" != "${d}" ]; then
		    printf "%12s\t" "(${d#*\(}"
		    local count=$(( ${count} + 1))
		    if [ ${count} = 8 ]; then
			printf "\n"
			count=0
		    fi
		fi
	    done

	    if [ ${count} != 0 ]; then
		printf "\n"
	    fi
	else
	    for d in $(ls -1 ${PAPERS_DIR}); do
		D=$(echo ${d#*\(}|tr '[:lower:]' '[:upper:]')
		if [ "${D}" = "$DIR)" ]; then
		    cd "${PAPERS_DIR}/${d}"
		    break
		fi
	    done
	fi
	IFS=$IFS_BAK
    fi
}

function find_notes
{
    NOTES_DIR=$(readlink -f $(find ${HOME}/ -type d -name notes -print -quit) 2> /dev/null)
    export NOTES_DIR
}

function notes
{
    if [ -n "${NOTES_DIR}" ]; then
	local DIR=$(echo $1|tr '[:upper:]' '[:lower:]')
	IFS_BAK=$IFS
	IFS=$'\n'
	if [ -z ${DIR} ]; then
	    local count=0
	    for d in $(ls -1 ${NOTES_DIR}); do
		if [ ! -f "${NOTES_DIR}/${d}/.hide" ]; then
		    printf "%8s\t" ${d}
		    count=$(( ${count} + 1 ))
		    if [ ${count} = 8 ]; then
			printf "\n"
			count=0
		    fi
		fi
	    done
	    if [ ${count} != 0 ]; then
		printf "\n"
	    fi
	else
	    for d in $(ls -1 ${NOTES_DIR}); do
		if [ "${d#${DIR}*}" != "${d}" ]; then
		    IFS=$IFS_BAK
		    emacs "${NOTES_DIR}/${d}/notes.org"
		    pushd ${NOTES_DIR} > /dev/null
		    commit ${d}/notes.org
		    popd > /dev/null
		    return 0
		fi
	    done
	    echo -n "Project not found.  Create new project [N/y]? "
	    read create
	    if [ "${create:0:1}" == 'y' -o "${create:0:1}" == 'Y' ]; then
		IFS=$IFS_BAK
		mkdir "${NOTES_DIR}/${DIR}"
		echo "#+TITLE: ${DIR}" > "${NOTES_DIR}/${DIR}/notes.org"
		cat "${NOTES_DIR}/.notes.tmpl" >> "${NOTES_DIR}/${DIR}/notes.org"
		emacs "${NOTES_DIR}/${DIR}/notes.org"
		pushd ${NOTES_DIR} > /dev/null
		commit ${DIR}/notes.org
		popd > /dev/null
		return 0
	    fi
	fi
	IFS=$IFS_BAK
    fi
}

function commit
{
    git rev-parse --show-toplevel 1> /dev/null 2> /dev/null
    local is_git=${?}
    ls -d .svn 1> /dev/null 2>/dev/null
    local is_svn=${?}
    if [ ${is_git} == 0 ]; then
	local BASE_DIR=$(git rev-parse --show-toplevel 2> /dev/null)
	local OBJ=${PWD#${BASE_DIR}}/${1}
	local OBJ=${OBJ#/}
	if [ -n "${OBJ}" ]; then
	    __git_commit ${OBJ}
	fi
    elif [ ${is_svn} == 0 ]; then
	local OBJ=${1}
	if [ -n "${OBJ}" ]; then
	    __svn_commit ${OBJ}
	fi
    else
	echo "No valid repository found"
	return 255
    fi
}

function __git_commit
{
    local OBJ=${1}
    echo -n "Commit changes to ${OBJ} [N/y]? "
    read commit
    if [ "${commit:0:1}" == 'y' -o "${commit:0:1}" == 'Y' ]; then
	echo -n "Message? "
	read message
	if [ -z "${message}" ]; then
	    echo "Aborting"
	    return 255
	fi
	git add ${OBJ}
	git ci -m "${message} (${OBJ})"
    fi
}

function __svn_commit
{
    local OBJ=${1}
    echo -n "Commit changes to ${OBJ} [N/y]? "
    read commit
    if [ "${commit:0:1}" == 'y' -o "${commit:0:1}" == 'Y' ]; then
	echo -n "Message? "
	read message
	if [ -z "${message}" ]; then
	    echo "Aborting"
	    return 255
	fi
	svn ci ${OBJ} -m "${message} (${OBJ})"
    fi
}

function bell
{
    notify-send "FINISHED JOB on $HOSTNAME: $@"
}

function _powerline_ps1 {
    export PS1="$(python ~/.home_env/powerline-bash.py $?)"
}

function _powerline_ps1_compat {
    export PS1="$(python ~/.home_env/powerline-bash.py $? --mode=compatible)"
}

function set_powerline_compat {
    export PROMPT_COMMAND=_powerline_ps1_compat
}

function ps1_toggle {
    local tmp=${PROMPT_COMMAND}
    export PROMPT_COMMAND=${_ALT_PROMPT_COMMAND}
    export _ALT_PROMPT_COMMAND=${tmp}
}

## Grabbed from the internetz - http://brettterpstra.com/fk-redux/
#find and list processes matching a case-insensitive partial-match string
# Mostly for OSX
function fp
{
    arg=${1-'.*'}
    ps Ao pid,comm | \
	awk '{match($0,/[^\/]+$|\W+$/); print substr($0,RSTART,RLENGTH)": "$1}' | \
	grep -i "${arg}" | \
	grep -v grep
}

function fk
{
    IFS_BAK=$IFS
    IFS=$'\n'
    PS3='Kill which process? (1 to cancel): '
    select OPT in "Cancel" $(fp $1); do
        if [ $OPT != "Cancel" ]; then
            kill $(echo $OPT|awk '{print $NF}')
        fi
        break
    done
    IFS=$IFS_BAK
}
